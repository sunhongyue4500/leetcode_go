package main

import "fmt"
import "leetcode/200/uf"

func main() {
	//input := [][]byte{[]byte{'1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','0','1','0','1','1'},[]byte{'0','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','0'},[]byte{'1','0','1','1','1','0','0','1','1','0','1','1','1','1','1','1','1','1','1','1'},[]byte{'1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},[]byte{'1','0','0','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},[]byte{'1','0','1','1','1','1','1','1','0','1','1','1','0','1','1','1','0','1','1','1'},[]byte{'0','1','1','1','1','1','1','1','1','1','1','1','0','1','1','0','1','1','1','1'},[]byte{'1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','0','1','1'},[]byte{'1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1'},[]byte{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},[]byte{'0','1','1','1','1','1','1','1','0','1','1','1','1','1','1','1','1','1','1','1'},[]byte{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},[]byte{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},[]byte{'1','1','1','1','1','0','1','1','1','1','1','1','1','0','1','1','1','1','1','1'},[]byte{'1','0','1','1','1','1','1','0','1','1','1','0','1','1','1','1','0','1','1','1'},[]byte{'1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','1','1','0'},[]byte{'1','1','1','1','1','1','1','1','1','1','1','1','1','0','1','1','1','1','0','0'},[]byte{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},[]byte{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'},{'1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1','1'}}
	//input := [][]byte{[]byte{'1','1','0','0','0'}, []byte{'1','1','0','0','0'}, []byte{'0','0','1','0','0'}, []byte{'0','0','0','1','1'}}
	//input := [][]byte{[]byte{'1'}}
	input := [][]byte{[]byte{'0'}, []byte{'0'}, []byte{'0'}}
	//input := [][]byte{[]byte{'1', '0', '0'}, []byte{'0', '0', '0'}, []byte{'0', '0', '1'}}
	//input := [][]byte{[]byte{'0', '0', '0', '1'}}
	fmt.Println(numIslands(input))

}

func numIslands(grid [][]byte) int {
	re := 0 // 存储最终结果
	nr := len(grid)
	if nr == 0 {
		return 0
	}
	nc := len(grid[0])

	ufTemp := uf.NewUF(nr * nc)

	// 初始化（0这个位置默认就是0，如果grid[0][0]是0就会多算一个）
	for i := 0; i < nr; i++ {
		for j := 0; j < nc; j++ {
			if grid[i][j] == '1' {
				ufTemp[i*nc+j] = i*nc + j
			}
		}
	}

	// 相邻的合并
	for i := 0; i < nr; i++ {
		for j := 0; j < nc; j++ {
			if grid[i][j] == '1' {
				// 和相邻的合并
				if i-1 >= 0 && grid[i-1][j] == '1' {
					ufTemp.Union(i*nc+j, (i-1)*nc+j)
				}
				if i+1 < nr && grid[i+1][j] == '1' {
					ufTemp.Union(i*nc+j, (i+1)*nc+j)
				}
				if j-1 >= 0 && grid[i][j-1] == '1' {
					ufTemp.Union(i*nc+j, i*nc+j-1)
				}
				if j+1 < nc && grid[i][j+1] == '1' {
					ufTemp.Union(i*nc+j, i*nc+j+1)
				}
			}
		}
	}
	// 计算有多少个parent
	re = ufTemp.ParentCount()
	// 如果开头第一个是0，就多算了一个
	if grid[0][0] == '0' {
		return re - 1
	}
	return re
}

//func numIslands(grid [][]byte) int {
//	nr := len(grid)
//	if nr == 0 {
//		return 0
//	}
//	nc := len(grid[0])
//	res := 0
//	for i:=0; i<nr; i++ {
//		for j:=0; j<nc; j++ {
//			if grid[i][j] == '1' {
//				res = res + 1
//				queue := make([]int, 0)
//				// 传入索引
//				queue = append(queue, i * nc + j)
//				for len(queue) != 0 {
//					temp := queue[0]
//					queue = queue[1:]
//					row := temp / nc
//					col := temp % nc
//					// 将相邻的都置成0
//					if row - 1 >= 0 && grid[row-1][col] == '1' {
//						queue = append(queue, (row - 1) * nc + col)
//						grid[row-1][col] = '0'
//					}
//					if row + 1 < nr && grid[row+1][col] == '1' {
//						queue = append(queue, (row + 1) * nc + col)
//						grid[row+1][col] = '0'
//					}
//					if col - 1 >= 0 && grid[row][col-1] == '1' {
//						queue = append(queue, row * nc + col - 1)
//						grid[row][col-1] = '0'
//					}
//					if col + 1 < nc && grid[row][col+1] == '1' {
//						queue = append(queue, row * nc + col + 1)
//						grid[row][col+1] = '0'
//					}
//				}
//			}
//		}
//	}
//	return res
//}
